a bit copying machine , called bitbitjump , copies one bit in memory and passes the execution unconditionally to the address specified by one of the operands of the instruction usually , some memory registers ( triggering ports ) within common address space perform an assigned operation when the instruction references them for example , in an oisc using a single memory-to-memory copy instruction , this is done by triggering ports that perform arithmetic and instruction pointer jumps when written to the instruction operates on integers which may also be addresses in memory common choices for the single instruction are : subtract and branch if less than or equal to zero subtract and branch if negative arithmetic machine reverse subtract and skip if borrow move ( used as part of a transport triggered architecture ) subtract and branch if non zero ( sbnz a , b , c , destination ) cryptoleq ( heterogeneous encrypted and unencrypted computation ) only one of these instructions is used in a given implementation however , it is possible to construct turing complete machines using an instruction based on other arithmetic operations , e.g the sbnz a , b , c , d instruction ( '' subtract and branch if not equal to zero '' ) subtracts the contents at address a from the contents at address b , stores the result at address c , and then , if the result is not 0 , transfers control to address d ( if the result is equal to zero , execution proceeds to the next instruction in sequence ) the instruction ( '' subtract and branch if less than or equal to zero '' ) subtracts the contents at address from the contents at address , stores the result at address , and then , if the result is not positive , transfers control to address ( if the result is positive , execution proceeds to the next instruction in sequence ) the result is stored in both the accumulator and the memory location , and the second operand specifies the branch address : subleq2 a , b ; mema mema - accum ; accum mema ; if ( mema â‰¤ 0 ) goto b although this uses only two ( instead of three ) operands per instruction , correspondingly more instructions are then needed to effect various logical operations , the following instructions result in the content at location being added to the content at location : ; : subleq a , z subleq z , b subleq z , z the first instruction subtracts the content at location from the content at location ( which is 0 ) and stores the result ( which is the negative of the content at in location the second instruction subtracts this result from , storing in this difference ( which is now the sum of the contents originally at and ; the third instruction restores the value 0 to , the following instructions result in the content at location getting replaced by the content at location , again assuming the content at location is maintained as 0 : ; : subleq b , b subleq a , z subleq z , b subleq z , z any desired arithmetic test can be built , self-interpreters , which may use self-modifying code as allowed by the nature of the instruction ) can be found in the external links below the instruction ( '' subtract and branch if negative '' ) , also called , is defined similarly to : subneg a , b , c ; memb memb - mema ; if ( memb conditional branching can be suppressed by setting the third operand equal to the address of the next instruction in sequence the machine is able to do one operation : take from location x as many counters as there are in location y and transfer them to location z and proceed to next instruction pseudocode : command x , y , z , t ; if ( memy after giving a few programs : multiplication , gcd , computing the n-th prime number , representation in base b of an arbitrary number , sorting in order of magnitude , melzac shows explicitly how to simulate an arbitrary turing machine on his arithmetic machine note 2 if the value stored at '' z '' is initially a negative value then the final '' rssb x '' will be skipped and thus the routine will not work this instruction moves the contents of one memory location to another memory location combining with the current content of the new location : move a to b ; memb : mema ( + , - , , / , so memory cells are not simple store but coupled with an arithmetic logic unit ( alu ) setup to perform only one sort of operation with the current value of the cell 