in vector-based graphics editing , each leaf node in a scene graph represents some atomic unit of the document , usually a shape such as an ellipse or bezier path internally , there may be no real structural difference between layers and groups at all , since they are both just nodes of a scene graph scene graphs are useful for modern games using 3d graphics and increasingly large worlds or levels the scene graph may also describe the spatial , as well as the logical , relationship of the various entities : the knight moves through 3d space as the horse moves in these large applications , memory requirements are major considerations when designing a scene graph for this reason , many large scene graph systems use geometry instancing to reduce memory costs and increase speed the simplest form of scene graph uses an array or linked list data structure , and displaying its shapes is simply a matter of linearly iterating the nodes one by one but since the underlying implementation of the rendering api usually lacks portability , one might separate the scene graph and rendering systems instead virtual functions are simple to write , but it is usually impossible to add new operations to nodes without access to the source code it demonstrates that a good scene graph implementation depends heavily on the application in which it is used a traversal generally consists of starting at some arbitrary node ( often the root of the scene graph ) , applying the operation ( s ) ( often the updating and rendering operations are applied one after the other ) , and recursively moving down the scene graph ( tree ) to the child nodes , until a leaf node is reached some scene graph operations are actually more efficient when nodes are traversed in a different order â€“ this is where some systems implement scene graph rebuilding to reorder the scene graph into an easier-to-parse format or tree an effective way of combining space partitioning and scene graphs is by creating a scene leaf node that contains the spatial partitioning data spatial data is usually static and generally contains non-moving scene data in some partitioned form in particular , it is bad to have the scene graph contained within the spatial partitioning system , as the scene graph is better thought of as the grander system to the spatial partitioning very large drawings , or scene graphs that are generated solely at runtime ( as happens in ray tracing rendering programs ) , require defining of group nodes in a more automated fashion a raytracer , for example , will take a scene description of a 3d model and build an internal representation that breaks up its individual parts into bounding boxes ( also called bounding slabs ) if the user has magnified a document so that only part of it is visible on his computer screen , and then scrolls in it , it is useful to use a bounding box ( or in this case , a bounding rectangle scheme ) to quickly determine which scene graph elements are visible and thus actually need to be drawn depending on the particulars of the application 's drawing performance , a large part of the scene graph 's design can be impacted by rendering efficiency considerations bsp trees , however , take a very long time to compute from design scene graphs , and must be recomputed if the design scene graph changes , so the levels tend to remain static , and dynamic characters are n't generally considered in the spatial partitioning scheme 