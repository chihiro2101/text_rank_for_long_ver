the observer pattern addresses the following problems : a one-to-many dependency between objects should be defined without making the objects tightly coupled it should be ensured that when one object changes state , an open-ended number of dependent objects are updated automatically the observer pattern can cause memory leaks , known as the lapsed listener problem , because in a basic implementation , it requires both explicit registration and explicit deregistration , as in the dispose pattern , because the subject holds strong references to the observers , keeping them alive typically , the observer pattern is implemented so the '' subject '' being '' observed '' is part of the object for which state changes are being observed ( and communicated to the observers ) in some ( non-polling ) implementations of the publish-subscribe pattern ( aka the pub-sub pattern ) , this is solved by creating a dedicated '' message queue '' server ( and sometimes an extra '' message handler '' object ) as an extra stage between the observer and the object being observed , thus decoupling the components other implementations of the publish-subscribe pattern , which achieve a similar effect of notification and communication to interested parties , do not use the observer pattern at all these concerns are typically handled in message queueing systems of which the observer pattern is only a small part the observer pattern may be used in the absence of publish-subscribe , as in the case where model status is frequently updated thus instead of being overloaded by change message , the observer will cause the view to represent the approximate state of the model at a regular interval instead , subject refers to the observer interface ( update ( ) ) for updating state , which makes the subject independent of how the state of dependent objects is updated 