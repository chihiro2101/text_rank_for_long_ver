a symbolic link contains a text string that is automatically interpreted and followed by the operating system as a path to another file or directory hard links do not link paths on different volumes or file system , whereas symbolic links may point to any file or directory irrespective of the volumes on which the link and target reside symbolic links operate transparently for many operations : programs that read or write to files named by a symbolic link will behave as if operating directly on the target file when the ln -s flag is specified , the symlink ( ) system call is used instead , creating a symbolic link the posix directory listing application , ls , denotes symbolic links with an arrow after the name , pointing to the name of the target file ( see following example ) , when the long directory list is requested ( -l option ) in order to obtain a listing of the linked directory , the path must include a trailing directory separator character ( '/ ' , slash ) early implementations of symbolic links stored the symbolic link information as data in regular files an improvement , called fast symlinks , allowed storage of the target path within the data structures used for storing file information on disk ( inodes ) systems with fast symlinks often fall back to using the original method if the target path exceeds the available inode space although storing the link value inside the inode saves a disk block and a disk read , the operating system still needs to parse the path name in the link , which always requires reading additional inodes and generally requires reading other , and potentially many , directories , processing both the list of files and the inodes of each of them until it finds a match with the link 's path components however , the posix standard does not require the entire set of file status information common to regular files to be implemented for symlinks unlike junction points , a symbolic link can also point to a file or remote server message block ( smb ) network path however , the functionality enabling cross-host symbolic links requires that the remote system also support them for example , windows vista users must manually indicate when creating a symbolic link whether it is a file or a directory in windows vista and later , when the working directory path ends with a symbolic link , the current parent path reference , , will refer to the parent directory of the symbolic link rather than that of its target this behaviour is also found at the shell level in at least some posix systems , including linux , but never in accessing files and directories through operating system calls when any path is used with a system call , any use of will use the actual filesystem parent of the directory containing the pseudo-directory entry shortcuts , which are supported by the graphical file browsers of some operating systems , may resemble symbolic links but differ in a number of important ways one difference is what type of software is able to follow them : symbolic links are automatically resolved by the file system another difference are the capabilities of the mechanism : microsoft windows shortcuts normally refer to a destination by an absolute path ( starting from the root directory ) , whereas posix symbolic links can refer to destinations via either an absolute or a relative path unlike symbolic links , windows shortcuts maintain their references to their targets even when the target is moved or renamed windows domain clients may subscribe to a windows service called distributed link tracking to track the changes in files and folders to which they are interested they are implemented as ordinary folders ( which need to have the read only and/or system attribute unable to remove read-only attribute from folder ) containing a shortcut named target.lnk which refers to the target and a ( hidden ) desktop.ini with ( at least ) the following contents : pyramid technology 's osx operating system implemented conditional symbolic links which pointed to different locations depending on which universe a program was running in 