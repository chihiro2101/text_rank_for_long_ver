a program to simulate this game would consist of several portions , one of which would be responsible for calculating the precise impacts between the billiard balls this particular example also turns out to be ill conditioned : a small error in any calculation will cause drastic changes in the final position of the billiard balls some use the softness of the material to calculate a force , which will resolve the collision in the following time steps like it is in reality collision detection utilizes time coherence to allow even finer time steps without much increasing cpu demand , such as in air traffic control after an inelastic collision , special states of sliding and resting can occur and , for example , the open dynamics engine uses constraints to simulate them in the a posteriori case , the physical simulation is advanced by a small step , then checked to see if any objects are intersecting or visibly considered intersecting at each simulation step , a list of all intersecting bodies is created , and the positions and trajectories of these objects are '' fixed '' to account for the collision in this case , the collision detection algorithm need not be aware of the myriad of physical variables ; a simple list of physical bodies is fed to the algorithm , and the program returns a list of intersecting bodies moreover , if the discrete step is too large , the collision could go undetected , resulting in an object which passes through another if it is sufficiently fast or small however , in all but the simplest cases , the problem of determining ahead of time when two bodies will collide ( given some initial data ) has no closed form solutionâ€”a numerical root finder is usually involved in all cases , resting contact requires special treatment : if two objects collide ( a posteriori ) or slide ( a priori ) and their relative motion is below a threshold , friction becomes stiction and both objects are arranged in the same branch of the scene graph in many applications , the configuration of physical bodies from one time step to the next changes very little at the coarse level of collision detection , the objective is to find pairs of objects which might potentially intersect despite this resource limit , and the use of relatively primitive collision detection algorithms , programmers have been able to create believable , if inexact , systems for use in games three-dimensional games have used spatial partitioning methods for n -body pruning , and for a long time used one or a few spheres per actual 3d object for pairwise checks exact checks are very rare , except in games attempting to simulate reality closely almost all games use a posteriori collision detection , and collisions are often resolved using very simple rules in many cases for video games , approximating the characters by a point is sufficient for the purpose of collision detection with the environment it is common for animated objects to have hitboxes attached to each moving part to ensure accuracy during motion bumping into a wall ) due to the difficulty experienced by both humans and ai in managing a hitbox 's ever-changing locations ; these sorts of collisions are typically handled with much simpler axis-aligned bounding boxes instead 